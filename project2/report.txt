I followed mostly the instructions and the provided steps in the paper. The first step was implementing the SWAG diagonal algorithm which was straight forward. I used the provided _create_weight_copy() function to create a dictionary for every parameter to save the first and second moment for each checkpoint frequency. After that, calculating the covariance matrix was straight forward as it is just the difference of the moments. Then I implemented the sampling part, I used the reparametrization trick used the standard deviation by squaring the covariance entry and the mean.
For the FULL SWAG part, I created a dictionary D which saves the low rank entries for each parameter. Here I flattened the parameter to faciliate the calculation of D*z2 in formula (1). All I had to do was then to update the sampling which reached the hard baseline.